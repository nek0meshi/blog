<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/blog/_next/static/css/15dc6a3128836163.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/15dc6a3128836163.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/6712705596c3ce9a.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/6712705596c3ce9a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-8b7febd1bced9880.js" defer=""></script><script src="/blog/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/blog/_next/static/chunks/main-5e639160cc5824a5.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-e07be00a65a2be40.js" defer=""></script><script src="/blog/_next/static/chunks/393-1e28617e1da6cdba.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-c0e78d37ea4396c8.js" defer=""></script><script src="/blog/_next/static/5X19qxgLC2QkQq_2Mkdxv/_buildManifest.js" defer=""></script><script src="/blog/_next/static/5X19qxgLC2QkQq_2Mkdxv/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.dsDmKE{font-size:1.8em;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="sc-7a2fb667-0"]{content:"dsDmKE,"}/*!sc*/
.CkIoe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:60px;padding:0 12px;}/*!sc*/
data-styled.g2[id="sc-b83349da-0"]{content:"CkIoe,"}/*!sc*/
.gZgVaN{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:150px;}/*!sc*/
data-styled.g3[id="sc-65db2cc7-0"]{content:"gZgVaN,"}/*!sc*/
.faTxYj{width:1024px;margin:2rem auto 0;}/*!sc*/
@media (max-width:1024px){.faTxYj{width:768px;}}/*!sc*/
@media (max-width:768px){.faTxYj{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:100px;width:100%;padding:0 12px;}}/*!sc*/
data-styled.g4[id="sc-86703585-0"]{content:"faTxYj,"}/*!sc*/
.biHffe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;width:100%;}/*!sc*/
data-styled.g5[id="sc-415e9204-0"]{content:"biHffe,"}/*!sc*/
.kFSSWF{width:100%;margin-right:10px;padding:7px;border:1px solid #444;border-radius:5px;font-size:1.2rem;}/*!sc*/
data-styled.g6[id="sc-415e9204-1"]{content:"kFSSWF,"}/*!sc*/
.loLrxI{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;gap:50px;}/*!sc*/
.loLrxI *{margin:0;}/*!sc*/
data-styled.g7[id="sc-f3c104c8-0"]{content:"loLrxI,"}/*!sc*/
.fdrrze{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:15px;text-align:center;}/*!sc*/
data-styled.g8[id="sc-f3c104c8-1"]{content:"fdrrze,"}/*!sc*/
.cJAFHI{margin-top:0;}/*!sc*/
data-styled.g9[id="sc-f3c104c8-2"]{content:"cJAFHI,"}/*!sc*/
.huBxYE{border-radius:50%;}/*!sc*/
data-styled.g10[id="sc-f3c104c8-3"]{content:"huBxYE,"}/*!sc*/
.jyiLaO{white-space:pre-wrap;}/*!sc*/
data-styled.g11[id="sc-f3c104c8-4"]{content:"jyiLaO,"}/*!sc*/
.ilwROs{width:100%;padding-inline-start:0;font-size:1.2rem;list-style-type:none;overflow:hidden;}/*!sc*/
.ilwROs li{width:100%;}/*!sc*/
.ilwROs a{display:inline-block;width:100%;height:40px;overflow:hidden;white-space:nowrap;-webkit-text-decoration:none;text-decoration:none;text-overflow:ellipsis;}/*!sc*/
data-styled.g12[id="sc-f3c104c8-5"]{content:"ilwROs,"}/*!sc*/
.MLuyj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;gap:50px;}/*!sc*/
data-styled.g13[id="sc-5a24f448-0"]{content:"MLuyj,"}/*!sc*/
.eEOreA{width:calc(100% - 50px - 240px);}/*!sc*/
@media (max-width:1024px){.eEOreA{width:calc(100% - 50px - 180px);}}/*!sc*/
@media (max-width:768px){.eEOreA{width:100%;}}/*!sc*/
data-styled.g14[id="sc-5a24f448-1"]{content:"eEOreA,"}/*!sc*/
.hUGdAH{width:240px;}/*!sc*/
@media (max-width:1024px){.hUGdAH{width:180px;}}/*!sc*/
@media (max-width:768px){.hUGdAH{width:100%;}}/*!sc*/
data-styled.g15[id="sc-5a24f448-2"]{content:"hUGdAH,"}/*!sc*/
.jrFJws *{word-wrap:break-word;}/*!sc*/
.jrFJws h1{margin:1.4rem 0 1rem;}/*!sc*/
.jrFJws h2{margin:3rem 0 0.8rem;}/*!sc*/
.jrFJws h2:first-child{margin-top:0.5rem;}/*!sc*/
.jrFJws h2 + h3{margin-top:1rem;}/*!sc*/
.jrFJws h3{margin:2.5rem 0 0.7rem;}/*!sc*/
.jrFJws h3 + h4{margin-top:0.7rem;}/*!sc*/
.jrFJws h4{margin:2rem 0 0.5rem;}/*!sc*/
.jrFJws a,.jrFJws img,.jrFJws pre{margin:1rem 0;}/*!sc*/
.jrFJws img{max-width:100%;}/*!sc*/
.jrFJws pre{overflow:scroll;}/*!sc*/
.jrFJws table{border-collapse:collapse;border-spacing:0;border-top:1px solid #f0f0f0;display:block;overflow-x:auto;width:100%;}/*!sc*/
.jrFJws th,.jrFJws td{min-width:100px;text-align:left;padding:8px 12px;}/*!sc*/
.jrFJws th{background-color:#f0f0f0;}/*!sc*/
.jrFJws td{border-bottom:1px solid #ddd;}/*!sc*/
data-styled.g19[id="sc-71c5d68d-0"]{content:"jrFJws,"}/*!sc*/
.glZqIN{margin-top:0.5rem;margin-bottom:1.5rem;}/*!sc*/
data-styled.g20[id="sc-71c5d68d-1"]{content:"glZqIN,"}/*!sc*/
</style></head><body><div id="__next"><header class="sc-b83349da-0 CkIoe"><a class="sc-7a2fb667-0 dsDmKE" href="/blog/">Yushi&#x27;s Tech Blog</a></header><div class="sc-86703585-0 sc-5a24f448-0 faTxYj MLuyj"><main class="sc-5a24f448-1 eEOreA"><article><small>2024-07-07</small><h1 class="sc-71c5d68d-1 glZqIN">TypeScriptでのInterfaceのマージについて</h1><div class="sc-71c5d68d-0 jrFJws article-content_ArticleContent__8CaWz"><!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <p>TypeScript は、静的型付けをサポートする JavaScript のスーパーセットとして、開発者に多くの便利な機能を提供します。その中でも「Interface のマージ」は、非常に強力で柔軟な機能の一つです。この記事では、TypeScript における Interface のマージについて詳しく説明し、その利点と使用例を紹介します。</p>
    <h2>Interface のマージとは？</h2>
    <p>TypeScript では、同じ名前のインターフェースが複数宣言された場合、それらは自動的にマージされます。これにより、追加の型情報を提供することができます。以下に簡単な例を示します。</p>
    <pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'John Doe'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
  <span class="hljs-attr">email</span>: <span class="hljs-string">'john@example.com'</span>,
}
</code></pre>
    <p>この例では、<code>User</code>インターフェースが 2 回宣言されていますが、TypeScript はこれらを 1 つのインターフェースとして扱い、すべてのプロパティを含むことになります。そのため、<code>user</code>オブジェクトは<code>name</code>、<code>age</code>、および<code>email</code>の 3 つのプロパティを持つ必要があります。</p>
    <h2>マージの利点</h2>
    <h3>拡張性の向上</h3>
    <p>インターフェースのマージは、コードの拡張性を向上させます。異なるモジュールやライブラリが同じインターフェースを拡張しても、互いに干渉することなく型情報を追加できます。</p>
    <h3>柔軟なコード構造</h3>
    <p>インターフェースを分割して宣言することで、コードの可読性と管理性が向上します。例えば、大規模なプロジェクトでは、各機能ごとにインターフェースを分割して定義することが可能です。</p>
    <pre><code class="hljs language-typescript"><span class="hljs-comment">// user.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
}

<span class="hljs-comment">// contact.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>
}
</code></pre>
    <p>このように、<code>User</code>インターフェースを異なるファイルに分割して定義することができます。</p>
    <h2>マージの使用例</h2>
    <h3>外部ライブラリの拡張</h3>
    <p>TypeScript で外部ライブラリを使用する際、そのライブラリの型定義を拡張するためにインターフェースのマージを使用することがよくあります。例えば、Express.js のリクエストオブジェクトにカスタムプロパティを追加する場合です。</p>
    <pre><code class="hljs language-typescript"><span class="hljs-comment">// express.d.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Request</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>

<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'express-serve-static-core'</span> {
  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Request</span> {
    user?: <span class="hljs-title class_">User</span>
  }
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
}
</code></pre>
    <p>この例では、<code>express-serve-static-core</code>モジュールの<code>Request</code>インターフェースに<code>user</code>プロパティを追加しています。</p>
    <h3>別の例: コンポーネントの拡張</h3>
    <p>React コンポーネントのプロパティを拡張する際にも、インターフェースのマージは有効です。以下の例では、<code>Button</code>コンポーネントのプロパティに<code>color</code>プロパティを追加しています。</p>
    <pre><code class="hljs language-typescript"><span class="hljs-comment">// buttonProps.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ButtonProps</span> {
  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>
}

<span class="hljs-comment">// buttonColorProps.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ButtonProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./buttonProps'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ButtonProps</span> {
  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>
}

<span class="hljs-comment">// Button.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ButtonProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./buttonColorProps'</span>

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">ButtonProps</span>> = <span class="hljs-function">(<span class="hljs-params">{ onClick, color }</span>) =></span> (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color</span> }} <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClick}</span>></span>
    Click me
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
)
</code></pre>
    <h2>注意点</h2>
    <p>インターフェースのマージは便利ですが、乱用するとコードが複雑になり、予期しない動作を引き起こす可能性があります。特に、同じプロパティ名で異なる型を持つインターフェースをマージする場合は注意が必要です。</p>
    <pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>
}

<span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: A = {
  <span class="hljs-attr">value</span>: <span class="hljs-string">'Hello'</span>, <span class="hljs-comment">// Error: Type 'string' is not assignable to type 'never'.</span>
}
</code></pre>
    <p>このような場合、TypeScript はプロパティの型を<code>never</code>として扱い、エラーが発生します。</p>
    <h2>まとめ</h2>
    <p>TypeScript のインターフェースのマージ機能は、柔軟で強力な型定義を可能にします。これにより、コードの拡張性と管理性が向上し、大規模なプロジェクトや外部ライブラリの拡張に役立ちます。しかし、乱用を避け、慎重に設計することが重要です。適切に活用することで、TypeScript の型システムを最大限に活用できるでしょう。</p>
    <hr>
    <p>※ この記事は生成 AI によって作成され、一部を編集したものです。</p>
  </body>
</html>
</div></article></main><aside class="sc-f3c104c8-0 loLrxI sc-5a24f448-2 hUGdAH"><section class="sc-f3c104c8-1 fdrrze"><h2 class="sc-f3c104c8-2 cJAFHI">Profile</h2><img alt="profile image" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="sc-f3c104c8-3 huBxYE" style="color:transparent" src="/blog/profile.png"/><div class="sc-f3c104c8-4 jyiLaO">
Webエンジニアのyushiです。
関西の企業で自社サービスを開発しています。
Backend・Frontendが主な専門範囲です。
<a href="https://nek0meshi.github.io/profile">プロフィールページ</a></div></section><section class="sc-f3c104c8-1 fdrrze"><h2 class="sc-f3c104c8-2 cJAFHI">Search</h2><form class="sc-415e9204-0 biHffe"><input type="search" class="sc-415e9204-1 kFSSWF" value=""/></form></section><section class="sc-f3c104c8-1 fdrrze"><h2 class="sc-f3c104c8-2 cJAFHI">Latest</h2><ul class="sc-f3c104c8-5 ilwROs"><li><a href="/blog/posts/20250620-db-transaction-lock/">DBのトランザクションとロック</a></li><li><a href="/blog/posts/20250627-til/">TIL 2025/06/27</a></li><li><a href="/blog/posts/20250624-web-tech-future/">2030年までのWeb開発</a></li><li><a href="/blog/posts/20250624-til/">TIL 2025/06/24</a></li><li><a href="/blog/posts/20250624-ai-fullstack/">イベント「技術の総合格闘技、生成AI時代のフルスタック開発」</a></li></ul></section></aside></div><footer class="sc-65db2cc7-0 gZgVaN">©︎ 2022-2024 YUSHI WATANABE</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"utf-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cp\u003eTypeScript は、静的型付けをサポートする JavaScript のスーパーセットとして、開発者に多くの便利な機能を提供します。その中でも「Interface のマージ」は、非常に強力で柔軟な機能の一つです。この記事では、TypeScript における Interface のマージについて詳しく説明し、その利点と使用例を紹介します。\u003c/p\u003e\n    \u003ch2\u003eInterface のマージとは？\u003c/h2\u003e\n    \u003cp\u003eTypeScript では、同じ名前のインターフェースが複数宣言された場合、それらは自動的にマージされます。これにより、追加の型情報を提供することができます。以下に簡単な例を示します。\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'john@example.com'\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n    \u003cp\u003eこの例では、\u003ccode\u003eUser\u003c/code\u003eインターフェースが 2 回宣言されていますが、TypeScript はこれらを 1 つのインターフェースとして扱い、すべてのプロパティを含むことになります。そのため、\u003ccode\u003euser\u003c/code\u003eオブジェクトは\u003ccode\u003ename\u003c/code\u003e、\u003ccode\u003eage\u003c/code\u003e、および\u003ccode\u003eemail\u003c/code\u003eの 3 つのプロパティを持つ必要があります。\u003c/p\u003e\n    \u003ch2\u003eマージの利点\u003c/h2\u003e\n    \u003ch3\u003e拡張性の向上\u003c/h3\u003e\n    \u003cp\u003eインターフェースのマージは、コードの拡張性を向上させます。異なるモジュールやライブラリが同じインターフェースを拡張しても、互いに干渉することなく型情報を追加できます。\u003c/p\u003e\n    \u003ch3\u003e柔軟なコード構造\u003c/h3\u003e\n    \u003cp\u003eインターフェースを分割して宣言することで、コードの可読性と管理性が向上します。例えば、大規模なプロジェクトでは、各機能ごとにインターフェースを分割して定義することが可能です。\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// user.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// contact.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n    \u003cp\u003eこのように、\u003ccode\u003eUser\u003c/code\u003eインターフェースを異なるファイルに分割して定義することができます。\u003c/p\u003e\n    \u003ch2\u003eマージの使用例\u003c/h2\u003e\n    \u003ch3\u003e外部ライブラリの拡張\u003c/h3\u003e\n    \u003cp\u003eTypeScript で外部ライブラリを使用する際、そのライブラリの型定義を拡張するためにインターフェースのマージを使用することがよくあります。例えば、Express.js のリクエストオブジェクトにカスタムプロパティを追加する場合です。\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// express.d.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eRequest\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003edeclare\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'express-serve-static-core'\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRequest\u003c/span\u003e {\n    user?: \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n    \u003cp\u003eこの例では、\u003ccode\u003eexpress-serve-static-core\u003c/code\u003eモジュールの\u003ccode\u003eRequest\u003c/code\u003eインターフェースに\u003ccode\u003euser\u003c/code\u003eプロパティを追加しています。\u003c/p\u003e\n    \u003ch3\u003e別の例: コンポーネントの拡張\u003c/h3\u003e\n    \u003cp\u003eReact コンポーネントのプロパティを拡張する際にも、インターフェースのマージは有効です。以下の例では、\u003ccode\u003eButton\u003c/code\u003eコンポーネントのプロパティに\u003ccode\u003ecolor\u003c/code\u003eプロパティを追加しています。\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// buttonProps.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eButtonProps\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// buttonColorProps.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eButtonProps\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./buttonProps'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eButtonProps\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Button.tsx\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eButtonProps\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./buttonColorProps'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eButtonProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ onClick, color }\u003c/span\u003e) =\u003e\u003c/span\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e }} \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{onClick}\u003c/span\u003e\u003e\u003c/span\u003e\n    Click me\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n    \u003ch2\u003e注意点\u003c/h2\u003e\n    \u003cp\u003eインターフェースのマージは便利ですが、乱用するとコードが複雑になり、予期しない動作を引き起こす可能性があります。特に、同じプロパティ名で異なる型を持つインターフェースをマージする場合は注意が必要です。\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e A {\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e A {\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: A = {\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Hello'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// Error: Type 'string' is not assignable to type 'never'.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n    \u003cp\u003eこのような場合、TypeScript はプロパティの型を\u003ccode\u003enever\u003c/code\u003eとして扱い、エラーが発生します。\u003c/p\u003e\n    \u003ch2\u003eまとめ\u003c/h2\u003e\n    \u003cp\u003eTypeScript のインターフェースのマージ機能は、柔軟で強力な型定義を可能にします。これにより、コードの拡張性と管理性が向上し、大規模なプロジェクトや外部ライブラリの拡張に役立ちます。しかし、乱用を避け、慎重に設計することが重要です。適切に活用することで、TypeScript の型システムを最大限に活用できるでしょう。\u003c/p\u003e\n    \u003chr\u003e\n    \u003cp\u003e※ この記事は生成 AI によって作成され、一部を編集したものです。\u003c/p\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n","title":"TypeScriptでのInterfaceのマージについて","date":"2024-07-07","matters":[{"slug":"2023-frontend-developer-roadmap","title":"2023年版Frontend Developer Roadmapを見てみる","date":"2023-08-21"},{"slug":"20250619-bff","title":"BFF（Backend For Frontend）とは","date":"2025-06-19"},{"slug":"20250620-db-transaction-lock","title":"DBのトランザクションとロック","date":"2026-06-24"},{"slug":"20250624-ai-fullstack","title":"イベント「技術の総合格闘技、生成AI時代のフルスタック開発」","date":"2025-06-24"},{"slug":"20250624-til","title":"TIL 2025/06/24","date":"2025-06-24"},{"slug":"20250624-web-tech-future","title":"2030年までのWeb開発","date":"2025-06-24"},{"slug":"20250627-til","title":"TIL 2025/06/27","date":"2025-06-27"},{"slug":"frontend-2025","title":"【React / Next.js / TypeScript 開発で今押さえておくべきこと（2025年版）】","date":"2025-06-19"},{"slug":"interface-merge","title":"TypeScriptでのInterfaceのマージについて","date":"2024-07-07"},{"slug":"interface-vs-types","title":"TypeScriptのinterfaceとtypeの使い分け","date":"2024-07-06"},{"slug":"material-ui","title":"Material UI: モダンなフロントエンド開発の強力なツール","date":"2024-08-16"},{"slug":"monorepo","title":"モダンフロントエンドとモノレポ","date":"2024-07-07"},{"slug":"my-blog-1","title":"【自作ブログ 1】自作ブログを作りたい","date":"2023-02-06"},{"slug":"my-blog-2","title":"【自作ブログ 2】Markdownをparseする","date":"2023-02-19"},{"slug":"react-vs-svelte","title":"React vs Svelte: モダンウェブ開発の新たな選択肢","date":"2024-07-07"}]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"interface-merge"},"buildId":"5X19qxgLC2QkQq_2Mkdxv","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>