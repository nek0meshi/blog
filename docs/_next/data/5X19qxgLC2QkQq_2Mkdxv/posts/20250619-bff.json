{"pageProps":{"content":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <h3>概要</h3>\n    <p>BFF（Backend For Frontend）は、フロントエンドごとに専用のバックエンド層を用意するアーキテクチャパターン。主に、複雑な UI を持つアプリケーションにおいて、データの取得・変換・整形・統合を行う中間層の役割を果たす。</p>\n    <hr>\n    <h3>なぜ BFF が必要か</h3>\n    <ul>\n      <li><strong>API の粒度調整</strong>: REST API や GraphQL など、バックエンド API が汎用的すぎる場合、画面単位で最適なレスポンスを得るのが難しい。</li>\n      <li><strong>データ統合</strong>: 複数のマイクロサービスやサードパーティ API からデータを集約し、フロント用に整形できる。</li>\n      <li><strong>UI ロジックの吸収</strong>: パーソナライズ、フィルター、ソートなど、表示上のロジックを BFF 側で担当し、フロントをシンプルに保てる。</li>\n      <li><strong>変更に強くなる</strong>: UI の変更に伴う API 仕様の変更を、BFF が吸収できることでバックエンドとの連携が柔軟になる。</li>\n    </ul>\n    <hr>\n    <h3>BFF の構成例</h3>\n    <ul>\n      <li><strong>BFF + REST API</strong>: 既存の REST API 群を集約して、画面単位に構成し直す。</li>\n      <li><strong>BFF + GraphQL</strong>: 各データソースを GraphQL で統合し、クライアントからの柔軟なクエリに応答。</li>\n      <li><strong>BFF + tRPC</strong>: フロントと型を共有する RPC ベースの通信。TypeScript と親和性が高く、Next.js などで活用。</li>\n      <li><strong>BFF 内蔵型</strong>: Next.js（App Router）や Nuxt などのフルスタックフレームワークで、ページ単位の API と UI を統合。</li>\n    </ul>\n    <hr>\n    <h3>実装技術の選択肢</h3>\n    <table>\n      <thead>\n        <tr>\n          <th>技術</th>\n          <th>特徴</th>\n          <th>向いているケース</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>Express</td>\n          <td>柔軟で自由度が高いが、手動管理が多い</td>\n          <td>小〜中規模 BFF</td>\n        </tr>\n        <tr>\n          <td>NestJS</td>\n          <td>DI/モジュール構成があり、大規模に強い</td>\n          <td>複数チーム BFF</td>\n        </tr>\n        <tr>\n          <td>Fastify</td>\n          <td>高速で型安全な実装が可能</td>\n          <td>パフォーマンス重視</td>\n        </tr>\n        <tr>\n          <td>Next.js</td>\n          <td>App Router で UI と API を共存可能</td>\n          <td>UI 主導プロダクト</td>\n        </tr>\n        <tr>\n          <td>tRPC</td>\n          <td>型共有と RPC 構成が簡単。API 定義が不要</td>\n          <td>TypeScript 環境向き</td>\n        </tr>\n      </tbody>\n    </table>\n    <hr>\n    <h3>BFF と他の技術の比較</h3>\n    <table>\n      <thead>\n        <tr>\n          <th>目的</th>\n          <th>BFF</th>\n          <th>GraphQL</th>\n          <th>REST</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>UI 特化</td>\n          <td>◎ UI に合わせて設計可能</td>\n          <td>△ クエリ調整はできるが共通スキーマ前提</td>\n          <td>△ 一般的に粒度が汎用的</td>\n        </tr>\n        <tr>\n          <td>複数データ統合</td>\n          <td>◎ 中間層で自由に統合可能</td>\n          <td>◎ Schema で統合できる</td>\n          <td>△ クライアント側での統合必要</td>\n        </tr>\n        <tr>\n          <td>型安全</td>\n          <td>◯ zod, TypeScript 等で担保可能</td>\n          <td>◎ GraphQL スキーマで厳格</td>\n          <td>△ OpenAPI ベースに依存</td>\n        </tr>\n        <tr>\n          <td>保守性・テスト</td>\n          <td>◎ UI 単位で分離しやすく、疎結合</td>\n          <td>△ リゾルバが肥大化しがち</td>\n          <td>◯ エンドポイントごとに明確</td>\n        </tr>\n      </tbody>\n    </table>\n    <hr>\n    <h3>BFF 設計のポイント</h3>\n    <ul>\n      <li><strong>画面・機能単位で API を切る</strong>（Component API 的な発想）</li>\n      <li><strong>バリデーション・型安全の担保</strong>（zod や OpenAPI）</li>\n      <li><strong>フロントと密に連携する設計</strong>（BFF はフロントチームが主体）</li>\n      <li><strong>認証・認可を含めるか明確にする</strong></li>\n      <li><strong>外部 API・DB アクセスの抽象化と責務分離</strong></li>\n    </ul>\n    <hr>\n    <h3>まとめ</h3>\n    <p>BFF は「フロントの都合に合わせて最適なバックエンドを構成する」ための手法。汎用的な API に依存するのではなく、フロントごとの要件・変更・表示ロジックを柔軟に扱えるのが最大の利点。Next.js や tRPC といった現代的ツールと組み合わせることで、BFF はますます実践的な選択肢になっている。</p>\n  </body>\n</html>\n","title":"BFF（Backend For Frontend）とは","date":"2025-06-19","matters":[{"slug":"2023-frontend-developer-roadmap","title":"2023年版Frontend Developer Roadmapを見てみる","date":"2023-08-21"},{"slug":"20250619-bff","title":"BFF（Backend For Frontend）とは","date":"2025-06-19"},{"slug":"20250620-db-transaction-lock","title":"DBのトランザクションとロック","date":"2026-06-24"},{"slug":"20250624-ai-fullstack","title":"イベント「技術の総合格闘技、生成AI時代のフルスタック開発」","date":"2025-06-24"},{"slug":"20250624-til","title":"TIL 2025/06/24","date":"2025-06-24"},{"slug":"20250624-web-tech-future","title":"2030年までのWeb開発","date":"2025-06-24"},{"slug":"20250627-til","title":"TIL 2025/06/27","date":"2025-06-27"},{"slug":"frontend-2025","title":"【React / Next.js / TypeScript 開発で今押さえておくべきこと（2025年版）】","date":"2025-06-19"},{"slug":"interface-merge","title":"TypeScriptでのInterfaceのマージについて","date":"2024-07-07"},{"slug":"interface-vs-types","title":"TypeScriptのinterfaceとtypeの使い分け","date":"2024-07-06"},{"slug":"material-ui","title":"Material UI: モダンなフロントエンド開発の強力なツール","date":"2024-08-16"},{"slug":"monorepo","title":"モダンフロントエンドとモノレポ","date":"2024-07-07"},{"slug":"my-blog-1","title":"【自作ブログ 1】自作ブログを作りたい","date":"2023-02-06"},{"slug":"my-blog-2","title":"【自作ブログ 2】Markdownをparseする","date":"2023-02-19"},{"slug":"react-vs-svelte","title":"React vs Svelte: モダンウェブ開発の新たな選択肢","date":"2024-07-07"}]},"__N_SSG":true}