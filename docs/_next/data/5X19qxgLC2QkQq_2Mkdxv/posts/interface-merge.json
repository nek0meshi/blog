{"pageProps":{"content":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <p>TypeScript は、静的型付けをサポートする JavaScript のスーパーセットとして、開発者に多くの便利な機能を提供します。その中でも「Interface のマージ」は、非常に強力で柔軟な機能の一つです。この記事では、TypeScript における Interface のマージについて詳しく説明し、その利点と使用例を紹介します。</p>\n    <h2>Interface のマージとは？</h2>\n    <p>TypeScript では、同じ名前のインターフェースが複数宣言された場合、それらは自動的にマージされます。これにより、追加の型情報を提供することができます。以下に簡単な例を示します。</p>\n    <pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-attr\">email</span>: <span class=\"hljs-built_in\">string</span>\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">user</span>: <span class=\"hljs-title class_\">User</span> = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'John Doe'</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span>,\n  <span class=\"hljs-attr\">email</span>: <span class=\"hljs-string\">'john@example.com'</span>,\n}\n</code></pre>\n    <p>この例では、<code>User</code>インターフェースが 2 回宣言されていますが、TypeScript はこれらを 1 つのインターフェースとして扱い、すべてのプロパティを含むことになります。そのため、<code>user</code>オブジェクトは<code>name</code>、<code>age</code>、および<code>email</code>の 3 つのプロパティを持つ必要があります。</p>\n    <h2>マージの利点</h2>\n    <h3>拡張性の向上</h3>\n    <p>インターフェースのマージは、コードの拡張性を向上させます。異なるモジュールやライブラリが同じインターフェースを拡張しても、互いに干渉することなく型情報を追加できます。</p>\n    <h3>柔軟なコード構造</h3>\n    <p>インターフェースを分割して宣言することで、コードの可読性と管理性が向上します。例えば、大規模なプロジェクトでは、各機能ごとにインターフェースを分割して定義することが可能です。</p>\n    <pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// user.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>\n}\n\n<span class=\"hljs-comment\">// contact.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">User</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-attr\">email</span>: <span class=\"hljs-built_in\">string</span>\n}\n</code></pre>\n    <p>このように、<code>User</code>インターフェースを異なるファイルに分割して定義することができます。</p>\n    <h2>マージの使用例</h2>\n    <h3>外部ライブラリの拡張</h3>\n    <p>TypeScript で外部ライブラリを使用する際、そのライブラリの型定義を拡張するためにインターフェースのマージを使用することがよくあります。例えば、Express.js のリクエストオブジェクトにカスタムプロパティを追加する場合です。</p>\n    <pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// express.d.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Request</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'express'</span>\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">'express-serve-static-core'</span> {\n  <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Request</span> {\n    user?: <span class=\"hljs-title class_\">User</span>\n  }\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>\n}\n</code></pre>\n    <p>この例では、<code>express-serve-static-core</code>モジュールの<code>Request</code>インターフェースに<code>user</code>プロパティを追加しています。</p>\n    <h3>別の例: コンポーネントの拡張</h3>\n    <p>React コンポーネントのプロパティを拡張する際にも、インターフェースのマージは有効です。以下の例では、<code>Button</code>コンポーネントのプロパティに<code>color</code>プロパティを追加しています。</p>\n    <pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// buttonProps.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ButtonProps</span> {\n  <span class=\"hljs-attr\">onClick</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-built_in\">void</span>\n}\n\n<span class=\"hljs-comment\">// buttonColorProps.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ButtonProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./buttonProps'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ButtonProps</span> {\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">string</span>\n}\n\n<span class=\"hljs-comment\">// Button.tsx</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ButtonProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./buttonColorProps'</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Button</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">ButtonProps</span>> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ onClick, color }</span>) =></span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color</span> }} <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick}</span>></span>\n    Click me\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></span>\n)\n</code></pre>\n    <h2>注意点</h2>\n    <p>インターフェースのマージは便利ですが、乱用するとコードが複雑になり、予期しない動作を引き起こす可能性があります。特に、同じプロパティ名で異なる型を持つインターフェースをマージする場合は注意が必要です。</p>\n    <pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">interface</span> A {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">number</span>\n}\n\n<span class=\"hljs-keyword\">interface</span> A {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">a</span>: A = {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'Hello'</span>, <span class=\"hljs-comment\">// Error: Type 'string' is not assignable to type 'never'.</span>\n}\n</code></pre>\n    <p>このような場合、TypeScript はプロパティの型を<code>never</code>として扱い、エラーが発生します。</p>\n    <h2>まとめ</h2>\n    <p>TypeScript のインターフェースのマージ機能は、柔軟で強力な型定義を可能にします。これにより、コードの拡張性と管理性が向上し、大規模なプロジェクトや外部ライブラリの拡張に役立ちます。しかし、乱用を避け、慎重に設計することが重要です。適切に活用することで、TypeScript の型システムを最大限に活用できるでしょう。</p>\n    <hr>\n    <p>※ この記事は生成 AI によって作成され、一部を編集したものです。</p>\n  </body>\n</html>\n","title":"TypeScriptでのInterfaceのマージについて","date":"2024-07-07","matters":[{"slug":"2023-frontend-developer-roadmap","title":"2023年版Frontend Developer Roadmapを見てみる","date":"2023-08-21"},{"slug":"20250619-bff","title":"BFF（Backend For Frontend）とは","date":"2025-06-19"},{"slug":"20250620-db-transaction-lock","title":"DBのトランザクションとロック","date":"2026-06-24"},{"slug":"20250624-ai-fullstack","title":"イベント「技術の総合格闘技、生成AI時代のフルスタック開発」","date":"2025-06-24"},{"slug":"20250624-til","title":"TIL 2025/06/24","date":"2025-06-24"},{"slug":"20250624-web-tech-future","title":"2030年までのWeb開発","date":"2025-06-24"},{"slug":"20250627-til","title":"TIL 2025/06/27","date":"2025-06-27"},{"slug":"frontend-2025","title":"【React / Next.js / TypeScript 開発で今押さえておくべきこと（2025年版）】","date":"2025-06-19"},{"slug":"interface-merge","title":"TypeScriptでのInterfaceのマージについて","date":"2024-07-07"},{"slug":"interface-vs-types","title":"TypeScriptのinterfaceとtypeの使い分け","date":"2024-07-06"},{"slug":"material-ui","title":"Material UI: モダンなフロントエンド開発の強力なツール","date":"2024-08-16"},{"slug":"monorepo","title":"モダンフロントエンドとモノレポ","date":"2024-07-07"},{"slug":"my-blog-1","title":"【自作ブログ 1】自作ブログを作りたい","date":"2023-02-06"},{"slug":"my-blog-2","title":"【自作ブログ 2】Markdownをparseする","date":"2023-02-19"},{"slug":"react-vs-svelte","title":"React vs Svelte: モダンウェブ開発の新たな選択肢","date":"2024-07-07"}]},"__N_SSG":true}